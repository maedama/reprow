package reprow

import (
	"errors"
	"github.com/cihub/seelog"
	"github.com/mitchellh/mapstructure"
	"os"
	"os/signal"
	"sync"
	"syscall"
)

type Config struct {
	Queue    map[string]interface{}
	Runner   map[string]interface{}
	LogLevel string `valid:"string" mapstructure:"log_level"`
}

// Server implements reprow server. It should be generated by NewServer function
type Server struct {
	queue  Queue
	runner Runner
	logger seelog.LoggerInterface
}

// New server makes and initialized Server with configurations.
// Examples of configurations file can be seen here https://github.com/maedama/reprow/tree/master/sample
func NewServer(configMap map[interface{}]interface{}) (*Server, error) {
	server := &Server{}
	err := server.configure(configMap)
	if err != nil {
		return nil, err
	} else {
		return server, nil
	}
}

// Run starts a server process until signals are trapped.
func (s *Server) Run() int {
	s.logger.Infof("runnig server.")
	defer seelog.Flush()

	jobChannel := make(chan Job)
	semaphore := make(chan bool, s.runner.MaximumConcurrency())
	exit := make(chan int)

	var wait sync.WaitGroup
	// Start dequeue.
	wait.Add(1)
	s.queue.Start(jobChannel)

	// Start runners
	go func() {
		wait.Add(1)
		for job := range jobChannel {
			semaphore <- true
			wait.Add(1)
			go func(job Job) {
				finalized := job.WaitFinalize()
				if finalized == true {
					_ = s.runner.Run(job)
				}
				<-semaphore
				wait.Done()
			}(job)
		}
		wait.Done()
	}()

	// Start Signal handlers
	go func() {
		sigCh := make(chan os.Signal, 1)
		var wantDown sync.Once
		signal.Notify(
			sigCh,
			syscall.SIGHUP,
			syscall.SIGINT,
			syscall.SIGTERM,
			syscall.SIGQUIT)

		for {
			sig := <-sigCh
			switch sig {
			default:
				wantDown.Do(func() {
					s.logger.Info("stopping dequeue, gracefully shutting down")
					s.queue.Stop()
					close(jobChannel)
					wait.Done()
				})
			}
		}
	}()

	go func() {
		wait.Wait()
		exit <- 0
	}()

	return <-exit
}

func (s *Server) configure(c map[interface{}]interface{}) error {

	var config Config
	err := mapstructure.Decode(c, &config)
	if err != nil {
		return errors.New("Failed to read config:e = " + err.Error())
	}

	err = s.configureLogger(config)
	if err != nil {
		return errors.New("failed to configure logger: " + err.Error())
	}

	err = s.configureQueue(config.Queue)
	if err != nil {
		return errors.New("failed to configure  queue: " + err.Error())
	}

	err = s.configureRunner(config.Runner)
	if err != nil {
		return errors.New("failed to configure runner: " + err.Error())
	}

	return nil
}

func (s *Server) configureLogger(config Config) error {

	level, found := seelog.LogLevelFromString(config.LogLevel)
	if !found {
		return errors.New("Log level not found")
	}
	logger, err := seelog.LoggerFromWriterWithMinLevel(os.Stdout, level)
	if err != nil {
		panic(err)
	}
	s.logger = logger
	return nil
}

func (s *Server) configureQueue(config map[string]interface{}) error {

	queueType := config["type"]
	var err error
	if queueType == nil {
		return errors.New("queue type required")
	}
	queueBuilder := queues[queueType.(string)]
	if queueBuilder == nil {
		return errors.New("queue not registered")
	}

	s.queue, err = queueBuilder.NewQueue(config, s.logger)
	if err != nil {
		return err
	}
	s.logger.Infof("Completed configuring queue=%s", queueType.(string))

	return nil
}

func (s *Server) configureRunner(config map[string]interface{}) error {

	var err error
	runnerType := config["type"]
	if runnerType == nil {
		return errors.New("runner type required")
	}
	runnerBuilder := runners[runnerType.(string)]
	if runnerBuilder == nil {
		return errors.New("runner not registered")
	}

	s.runner, err = runnerBuilder.NewRunner(config, s.logger)
	if err != nil {
		return err
	}

	s.logger.Infof("Completed configuring runner=%s", runnerType.(string))
	return nil
}
